如果记得到划分数的话，这道题的递推关系就十分好推了。
此类划分数（因为记不清叫啥了。。）记住dp状态表示的是，总大小i时，最大元素小于等于j。按照最大值来区分状态
dp[i][j] = dp[i][j-1] + dp[i-j][j];
而，我在dp上记得划分数，不是这个定义，但是是一样的公式，有待揣摩。有相通之处。 见再学dp 划分数。

需要记住的是划分数往往很大。这道题没有求余，因此，long long 是要爆的。
学到了用high[i][j]表示高位，low[i][j] 表示低位的方法。一样的写，需要注意的是。high数组要加上low的进位。
                low[i][j] = (low[i][j-1]+low[i-j][j]) % inf;
                high[i][j] += high[i-j][j] + (low[i][j-1]+low[i-j][j])/inf;
inf为1e18， 即可表示大小最大为1e36的数。

wa了一次debug的时候有点失去信心了，错在const int inf = 1e18.  而不是递推那部分写错了。多点信心。

